#ifndef SCATHA_SEMA_FWD_H_
#define SCATHA_SEMA_FWD_H_

#include <iosfwd>
#include <string_view>

#include <scatha/Common/Base.h>
#include <scatha/Common/Dyncast.h>

namespace scatha::sema {

class Conversion;
class FunctionSignature;
class SemanticIssue;
class SymbolTable;

///
/// # Forward Declaration of all entity types
///

#define SC_SEMA_ENTITY_DEF(Type, _) class Type;
#include <scatha/Sema/Lists.def>

/// List of all entity types
enum class EntityType {
#define SC_SEMA_ENTITY_DEF(Type, _) Type,
#include <scatha/Sema/Lists.def>
    _count
};

SCATHA_API std::string_view toString(EntityType);

SCATHA_API std::ostream& operator<<(std::ostream&, EntityType);

} // namespace scatha::sema

/// Map types to enum values
#define SC_SEMA_ENTITY_DEF(Type, Abstractness)                                 \
    SC_DYNCAST_MAP(::scatha::sema::Type,                                       \
                   ::scatha::sema::EntityType::Type,                           \
                   Abstractness)
#include <scatha/Sema/Lists.def>

namespace scatha::sema {

/// Forward declaration of `QualType` class
/// See "Sema/QualType.h" for details.
class QualType;

enum class EntityCategory { Indeterminate, Value, Type, _count };

SCATHA_API std::ostream& operator<<(std::ostream&, EntityCategory);

enum class ValueCategory : u8 { None, LValue, RValue, _count };

SCATHA_API std::ostream& operator<<(std::ostream&, ValueCategory);

///
enum class ScopeKind {
    Invalid,
    Global,
    Namespace,
    Variable,
    Function,
    Object,
    Anonymous,
    _count
};

SCATHA_API std::string_view toString(ScopeKind);

SCATHA_API std::ostream& operator<<(std::ostream&, ScopeKind);

///
enum class FunctionKind : u8 { Native, External, Generated };

SCATHA_API std::string_view toString(FunctionKind);

SCATHA_API std::ostream& operator<<(std::ostream&, FunctionKind);

///
enum class AccessSpecifier : uint8_t { Public, Private };

/// Signedness of arithmetic types
enum class Signedness { Signed, Unsigned };

/// Reference qualifiers of `QualType`
enum class Reference { Implicit, Explicit };

inline constexpr Reference RefImpl = Reference::Implicit;

inline constexpr Reference RefExpl = Reference::Explicit;

/// \Returns `true` if \p type is a `ReferenceType`
bool isRef(QualType type);

/// \Returns `true` if \p type is a `ReferenceType` and is an implicit reference
bool isImplRef(QualType type);

/// \Returns `true` if \p type is a `ReferenceType` and is an explicit reference
bool isExplRef(QualType type);

/// \Returns `type->reference()` if \p type is a reference type, otherwise
/// `std::nullopt`
std::optional<Reference> refKind(QualType type);

/// \Returns \p type, if it is not a reference type, otherwise `type->base()`
QualType stripReference(QualType type);

/// \Returns `stripReference(type).toMut()`
QualType stripQualifiers(QualType type);

/// Mutability qualifiers of `QualType`
enum class Mutability { Const, Mutable };

/// Special member functions
/// These are all constructors, destructor, and perhaps more to come
enum class SpecialMemberFunction : uint8_t {
#define SC_SEMA_SPECIAL_MEMBER_FUNCTION_DEF(Name, str) Name,
#include <scatha/Sema/Lists.def>
};

} // namespace scatha::sema

SC_ENUM_SIZE_LAST_DEF(scatha::sema::SpecialMemberFunction, Delete);

namespace scatha::sema {

SCATHA_API std::string_view toString(SpecialMemberFunction);

SCATHA_API std::ostream& operator<<(std::ostream&, SpecialMemberFunction);

/// Special lifetime functions
/// These are the default constructor, the copy and move constructors and the
/// destructor These are special in the sense that they will be automatically
/// generated by the compiler
enum class SpecialLifetimeFunction : uint8_t {
#define SC_SEMA_SPECIAL_LIFETIME_FUNCTION_DEF(Name) Name,
#include <scatha/Sema/Lists.def>
};

/// Get the corresponding special member function (`new`, `move` or `delete`)
SCATHA_API SpecialMemberFunction toSMF(SpecialLifetimeFunction);

} // namespace scatha::sema

SC_ENUM_SIZE_LAST_DEF(scatha::sema::SpecialLifetimeFunction, Destructor);

namespace scatha::sema {

///
enum class FunctionAttribute : unsigned {
    None = 0,
    All = unsigned(-1),
    Const = 1 << 0,
    Pure = 1 << 1
};

UTL_BITFIELD_OPERATORS(FunctionAttribute);

///
/// # Constant Expressions
///

#define SC_SEMA_CONSTKIND_DEF(Type, _) class Type;
#include <scatha/Sema/Lists.def>

/// List of all constant value kinds
enum class ConstantKind {
#define SC_SEMA_CONSTKIND_DEF(Type, _) Type,
#include <scatha/Sema/Lists.def>
    _count
};

SCATHA_API std::string_view toString(ConstantKind);

SCATHA_API std::ostream& operator<<(std::ostream&, ConstantKind);

} // namespace scatha::sema

/// Map constant kinds to enum values
#define SC_SEMA_CONSTKIND_DEF(Type, Abstractness)                              \
    SC_DYNCAST_MAP(::scatha::sema::Type,                                       \
                   ::scatha::sema::ConstantKind::Type,                         \
                   Abstractness)
#include <scatha/Sema/Lists.def>

namespace scatha::sema {

/// Insulated call to `delete` on the most derived base of \p entity
SCATHA_API void privateDelete(sema::Entity* entity);

/// Insulated call to destructor on the most derived base of \p entity
SCATHA_API void privateDestroy(sema::Entity* entity);

/// Insulated call to `delete` on the most derived base of \p value
SCATHA_API void privateDelete(sema::Value* value);

/// Insulated call to destructor on the most derived base of \p value
SCATHA_API void privateDestroy(sema::Value* type);

} // namespace scatha::sema

#endif // SCATHA_SEMA_FWD_H_
