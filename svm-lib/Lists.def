// No include guards

// ===----------------------------------------------------------------------===
// === List of all VM instructions -----------------------------------------===
// ===----------------------------------------------------------------------===

#ifndef SVM_INSTRUCTION_DEF
#   define SVM_INSTRUCTION_DEF(inst, class)
#endif

/// ** Function call and return **
/// Performs the following operations:
/// ```
/// regPtr    += regOffset
/// regPtr[-3] = stackPtr
/// regPtr[-2] = regOffset
/// regPtr[-1] = iptr
/// jmp          offset
/// ```
SVM_INSTRUCTION_DEF(call, Other) // (i32 offset, u8 regOffset)

/// Return to caller. Effectively performs the following operations:
/// ```
/// iptr     = regPtr[-1]
/// regPtr  -= regPtr[-2]
/// stackPtr = regPtr[-3]
/// ```
SVM_INSTRUCTION_DEF(ret, Other)

/// Immediately terminates the program.
SVM_INSTRUCTION_DEF(terminate, Other)

/// ** Loads and stores **
/// Copies the value from the source operand (right) into the destination
/// operand (right).
SVM_INSTRUCTION_DEF(mov64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(mov64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(mov8MR,  MR) // (MEMORY_POINTER, u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(mov16MR, MR) // (MEMORY_POINTER, u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(mov32MR, MR) // (MEMORY_POINTER, u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(mov64MR, MR) // (MEMORY_POINTER, u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(mov8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(mov16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(mov32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(mov64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// ** Conditional moves **
/// `cmov` instruction cannot move _to_ memory, only to registers.
/// Perform move if `equal` flag is set
SVM_INSTRUCTION_DEF(cmove64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(cmove64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(cmove8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmove16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmove32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmove64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// Perform move if `not equal` flag is set
SVM_INSTRUCTION_DEF(cmovne64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(cmovne64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(cmovne8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovne16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovne32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovne64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// Perform move if `less` flag is set
SVM_INSTRUCTION_DEF(cmovl64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(cmovl64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(cmovl8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovl16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovl32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovl64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// Perform move if `less or equal` flag is set
SVM_INSTRUCTION_DEF(cmovle64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(cmovle64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(cmovle8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovle16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovle32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovle64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// Perform move if `greater` flag is set
SVM_INSTRUCTION_DEF(cmovg64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(cmovg64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(cmovg8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovg16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovg32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovg64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// Perform move if `greater or equal` flag is set
SVM_INSTRUCTION_DEF(cmovge64RR, RR) // (u8 destRegIdx,  u8 sourceRegIdx)
SVM_INSTRUCTION_DEF(cmovge64RV, RV) // (u8 destRegIdx,  u64 sourceValue)
SVM_INSTRUCTION_DEF(cmovge8RM,  RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovge16RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovge32RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)
SVM_INSTRUCTION_DEF(cmovge64RM, RM) // (u8 destRegIdx,  MEMORY_POINTER)

/// Store the stack pointer into register `destRegIdx` and increment it  by `offset` bytes
SVM_INSTRUCTION_DEF(lincsp, Other)  // (u8 destRegIdx, u16 offset)

/// ** Jumps **
/// Jumps are performed by adding the `offset` argument to the instruction
/// pointer.
/// This means a jump with `offset` 0 will jump to itself and thus enter an
/// infinite loop.

/// Jump to the specified offset.
SVM_INSTRUCTION_DEF(jmp, Jump) // (i32 offset)

/// Jump to the specified offset if equal flag is set.
SVM_INSTRUCTION_DEF(je,  Jump) // (i32 offset)

/// Jump to the specified offset if equal flag is not set.
SVM_INSTRUCTION_DEF(jne, Jump) // (i32 offset)

/// Jump to the specified offset if less flag is set.
SVM_INSTRUCTION_DEF(jl,  Jump) // (i32 offset)

/// Jump to the specified offset if less flag or equal flag is set.
SVM_INSTRUCTION_DEF(jle, Jump) // (i32 offset)

/// Jump to the specified offset if less flag and equal flag are not set.
SVM_INSTRUCTION_DEF(jg,  Jump) // (i32 offset)

/// Jump to the specified offset if less flag is not set.
SVM_INSTRUCTION_DEF(jge, Jump) // (i32 offset)

/// ** Comparison **
/// Compare the operands and set flags accordingly
SVM_INSTRUCTION_DEF(ucmpRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(scmpRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(ucmpRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(scmpRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(fcmpRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(fcmpRV, RV) //  (u8 regIdxA, u64 value)

/// Compare the operand to 0 and set flags accordingly
SVM_INSTRUCTION_DEF(stest, R) //  (u8 regIdx)
SVM_INSTRUCTION_DEF(utest, R) //  (u8 regIdx)

/// ** Read comparison results **
/// Set register to 0 or 1 based of the flags set by the `*cmp*` or `*test`
/// instructions
SVM_INSTRUCTION_DEF(sete,  R) //  (u8 regIdx)
SVM_INSTRUCTION_DEF(setne, R) //  (u8 regIdx)
SVM_INSTRUCTION_DEF(setl,  R) //  (u8 regIdx)
SVM_INSTRUCTION_DEF(setle, R) //  (u8 regIdx)
SVM_INSTRUCTION_DEF(setg,  R) //  (u8 regIdx)
SVM_INSTRUCTION_DEF(setge, R) //  (u8 regIdx)

/// ** Unary operations **
/// reg[regIdx] = !reg[regIdx]
SVM_INSTRUCTION_DEF(lnt, R) // (u8 regIdx)
/// reg[regIdx] = ~reg[regIdx]
SVM_INSTRUCTION_DEF(bnt, R) // (u8 regIdx)

/// ** Integer arithmetic **

/// reg[regIdxA] += reg[regIdxA]
SVM_INSTRUCTION_DEF(addRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] += value
SVM_INSTRUCTION_DEF(addRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] += memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(addRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] -= reg[regIdxA]
SVM_INSTRUCTION_DEF(subRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] -= value
SVM_INSTRUCTION_DEF(subRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] -= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(subRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] *= reg[regIdxA]
SVM_INSTRUCTION_DEF(mulRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] *= value
SVM_INSTRUCTION_DEF(mulRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] *= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(mulRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] /= reg[regIdxA]
SVM_INSTRUCTION_DEF(udivRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] /= value
SVM_INSTRUCTION_DEF(udivRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] /= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(udivRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] /= reg[regIdxA]
SVM_INSTRUCTION_DEF(sdivRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] /= value (signed arithmetic)
SVM_INSTRUCTION_DEF(sdivRV, RV) // (u8 regIdx, u64 value) (signed arithmetic)

/// reg[regIdxA] /= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(sdivRM, RM) // (u8 regIdxA, MEMORY_POINTER) (signed arithmetic)

/// reg[regIdxA] %= reg[regIdxA]
SVM_INSTRUCTION_DEF(uremRR,  RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] %= value
SVM_INSTRUCTION_DEF(uremRV,  RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] %= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(uremRM,  RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] %= reg[regIdxA]
SVM_INSTRUCTION_DEF(sremRR, RR) // (u8 regIdxA, u8 regIdxA) (signed arithmetic)

/// reg[regIdx] %= value
SVM_INSTRUCTION_DEF(sremRV, RV) // (u8 regIdx, u64 value) (signed arithmetic)

/// reg[regIdxA] %= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(sremRM, RM) // (u8 regIdxA, MEMORY_POINTER) (signed arithmetic)

/// MARK: Floating point arithmetic

/// reg[regIdxA] += reg[regIdxA]
SVM_INSTRUCTION_DEF(faddRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] += value
SVM_INSTRUCTION_DEF(faddRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] += memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(faddRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] -= reg[regIdxA]
SVM_INSTRUCTION_DEF(fsubRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] -= value
SVM_INSTRUCTION_DEF(fsubRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] -= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(fsubRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] *= reg[regIdxA]
SVM_INSTRUCTION_DEF(fmulRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx] *= value
SVM_INSTRUCTION_DEF(fmulRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] *= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(fmulRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// reg[regIdxA] /= reg[regIdxA]
SVM_INSTRUCTION_DEF(fdivRR, RR) // (u8 regIdxA, u8 regIdxA)

/// reg[regIdx]  /= value
SVM_INSTRUCTION_DEF(fdivRV, RV) // (u8 regIdx, u64 value)

/// reg[regIdxA] /= memory[eval(MEMORY_POINTER)]
SVM_INSTRUCTION_DEF(fdivRM, RM) // (u8 regIdxA, MEMORY_POINTER)

/// ** Logical bitshift **
SVM_INSTRUCTION_DEF(lslRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(lslRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(lslRM, RM) //  (u8 regIdxA, MEMORY_POINTER)
SVM_INSTRUCTION_DEF(lsrRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(lsrRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(lsrRM, RM) //  (u8 regIdxA, MEMORY_POINTER)

/// ** Arithmetic bitshift **
SVM_INSTRUCTION_DEF(aslRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(aslRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(aslRM, RM) //  (u8 regIdxA, MEMORY_POINTER)
SVM_INSTRUCTION_DEF(asrRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(asrRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(asrRM, RM) //  (u8 regIdxA, MEMORY_POINTER)

/// ** Bitwise AND/OR **
SVM_INSTRUCTION_DEF(andRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(andRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(andRM, RM) //  (u8 regIdxA, MEMORY_POINTER)
SVM_INSTRUCTION_DEF(orRR,  RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(orRV,  RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(orRM,  RM) //  (u8 regIdxA, MEMORY_POINTER)
SVM_INSTRUCTION_DEF(xorRR, RR) //  (u8 regIdxA, u8 regIdxB)
SVM_INSTRUCTION_DEF(xorRV, RV) //  (u8 regIdxA, u64 value)
SVM_INSTRUCTION_DEF(xorRM, RM) //  (u8 regIdxA, MEMORY_POINTER)

/// ** Misc **
// extFunctionTable[tableIdx][idxIntoTable](regPtr + regPtrOffset, this)
SVM_INSTRUCTION_DEF(callExt, Other) // (u8 regPtrOffset, u8 tableIdx, u16 idxIntoTable)

#undef SVM_INSTRUCTION_DEF
